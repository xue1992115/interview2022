<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      canvas {
        box-shadow: 0px 0px 5px #ccc;
        border-radius: 8px;
      }
    </style>
  </head>
  <body>
    <canvas id="mycanvas" width="1000" height="1000"> </canvas>
    <script>
      // 参考文章：https://juejin.cn/post/7119495608938790942#heading-50
      const g = document.getElementById("mycanvas");
      if (g.getContext) {
        // getConetxt 获取绘图上下文
        //  * getContext
        //  * @parmas 绘制上下文类型
        //  * 2d: 绘制一个二维上下文绘画
        //  * webgl： WebGLRenderingContext三维渲染上下文对象
        //  * webgl2： WebGL2RenderingContext三维渲染上下文对象
        //  * bitmaprenderer： ：创建一个只提供将canvas内容替换为指定ImageBitmap功能的
        const ctx = g.getContext("2d");
        // 1、绘制图形（直线、三角形、矩形、圆形、弧度）
        // ctx.moveTo(0, 0);
        // ctx.lineTo(200, 200);
        // ctx.stroke();

        // 2、绘制三角形 需要闭合，采用拼凑的点
        // ctx.moveTo(10, 0);
        // ctx.lineTo(100, 100);
        // ctx.lineTo(10, 200);
        // ctx.lineTo(10, 0);
        // ctx.stroke();

        // 3、绘制矩形
        // 画矩形遍
        // ctx.strokeRect(0, 0, 100, 100);
        // 填充矩形
        // ctx.fillRect(0, 0, 100, 100);
        // 清除部分区域的填充
        // ctx.clearRect(10, 10, 20, 20);
        // ctx.stroke();

        // 4、圆形和弧形

        // acr的单位是弧度
        // ctx.beginPath(); // 开启路径
        // ctx.arc(20, 20, 20, 0, 2 * Math.PI, false);
        // ctx.stroke();

        // beginPath表示开始一条新的路径
        // ctx.beginPath();
        // 绘制一个圆弧
        // ctx.arc(100, 60, 50, 0, Math.PI, false);
        // ctx.stroke();

        // ctx.beginPath();
        // 绘制一个圆弧
        // ctx.arc(60, 60, 50, 0, Math.PI, false);
        // closePath是指的闭合路径
        // ctx.closePath();
        // ctx.stroke();
        // 注意⚠️： 每次绘画开启路径是必须的，闭合路径却不是必须的

        // 5、填充一个圆 fill
        // ctx.beginPath(); // 开启路径
        // ctx.arc(60, 100, 50, 0, Math.PI / 2, false);
        // ctx.fill();

        // 6、椭圆绘制
        // x/y: x/y坐标点
        // radiusX/Y:x轴和y轴的半径
        // rotation：椭圆的旋转角度，以弧度表示
        // startAngle：开始绘制点
        // endAngle：结束绘制点
        // anticlockwise: 绘制的方向（默认顺时针），可选参数
        // ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise)
        // ctx.beginPath();
        // ctx.ellipse(50, 100, 50, 80, 0, 0, 2 * Math.PI);
        // ctx.stroke();

        // ctx.beginPath();
        // ctx.ellipse(100, 100, 50, 80, Math.PI / 2, 0, 2 * Math.PI); // 旋转90°
        // ctx.fill();

        // 7、贝塞尔曲线
        // quadraticCurveTo(cp1x, cp1y, x, y)，其中cp1x和cp1y为一个控制点，x和y为结束点
        // 绘制一段二次贝塞尔曲线
        // ctx.moveTo(0, 0);
        // ctx.quadraticCurveTo(100, 100, 150, 50);
        // // 绘制
        // ctx.stroke();

        // 语法：ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x, y)，其中cp1x和cp1y为一个控制点，cp2x和cp2y为第二个控制点，x和y为结束点。
        // 绘制一段三次贝塞尔曲线
        // ctx.beginPath(); // 开启路径
        // ctx.moveTo(50, 200);
        // ctx.bezierCurveTo(150, 50, 250, 350, 350, 200);
        // 线条宽度
        // ctx.lineWidth = 10;
        // 设置线条两端的样式 默认butt
        // ctx.lineCap = "butt";
        // ctx.lineCap = "round";
        // ctx.lineCap = "square";
        // 绘制
        // ctx.stroke();

        // 两条线连接处的样式 lineJoin
        // ctx.beginPath();
        // ctx.lineWidth = 10;
        // miter
        // ctx.lineJoin = "miter";
        // ctx.lineJoin = "bevel";
        // ctx.lineJoin = "round";
        // 设置透明度
        // ctx.globalAlpha = 0.5;
        // ctx.moveTo(50, 20);
        // ctx.lineTo(100, 60);
        // ctx.lineTo(150, 20);
        // ctx.lineTo(200, 60);
        // ctx.lineTo(250, 20);
        // ctx.stroke();
        // ctx.closePath();

        // 8、渐变颜色
        // 语法：ctx.createLinearGradient(x1, y1, x2, y2)
        // 分别为其实坐标点和结束坐标点
        // 在渐变的设置中还需要一个方法来添加渐变的颜色，语法为：gradient.addColorStop(offset, color)，其中color就是颜色，offset 则是颜色的偏移值，只为0到1之间的数。
        // 创建渐变色
        // var gradient1 = ctx.createLinearGradient(10, 10, 400, 10);
        // 增加颜色
        // gradient1.addColorStop(0, "#0000ff");
        // gradient1.addColorStop(1, "#ff0000");
        // ctx.fillStyle = gradient1;
        // ctx.fillRect(10, 150, 400, 100);

        // 从0.5的位置才开始渐变
        // ctx.beginPath();
        // var gradient2 = ctx.createLinearGradient(10, 10, 400, 10);
        // gradient2.addColorStop(0.5, "#00ff00");
        // gradient2.addColorStop(1, "#ff0000");
        // ctx.fillStyle = gradient2;
        // ctx.fillRect(10, 150, 400, 100);

        // 9、径向渐变
        // 参数分别为开始圆的坐标和半径以及结束圆的坐标和半径
        // ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)
        // 创建渐变
        // 结束坐标为点
        // var gradient1 = ctx.createRadialGradient(100, 100, 100, 100, 100, 0);
        // gradient1.addColorStop(0, "#ff770f");
        // gradient1.addColorStop(1, "#ffffff");
        // // 结束坐标为半径30的圆
        // var gradient2 = ctx.createRadialGradient(320, 100, 100, 320, 100, 30);
        // gradient2.addColorStop(0, "#ff770f");
        // gradient2.addColorStop(1, "#ffffff");
        // ctx.beginPath();
        // ctx.fillStyle = gradient1;
        // ctx.fillRect(10, 10, 200, 200);
        // ctx.beginPath();
        // ctx.fillStyle = gradient2;
        // ctx.fillRect(220, 10, 200, 200);

        // 10、图像
        // 创建一个 image对象
        // var img = new Image();
        // img.src = "./images/01.jpeg";
        // img.onload = function () {
        //   // 图片加载完以后
        //   // 创建图案
        //   // var ptrn = ctx.createPattern(img, "no-repeat");
        //   var ptrn = ctx.createPattern(img, "repeat");
        //   ctx.fillStyle = ptrn;
        //   ctx.fillRect(0, 0, 500, 500);
        // };

        // 11、绘制文本
        // ctx.font = "50px serif"; // 设置文案大小和字体
        // // ctx.strokeText("Canvas 详解", 50, 50);
        // ctx.direction = "ltr"; // 文本方向从左向右
        // ctx.textAlign = "left"; // 左对齐
        // ctx.fillText("Canvas 详解", 50, 50);

        // 12、绘制图像
        // var img = new Image();
        // img.src =
        //   "https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20191212%2F556cc408058d4c64a46468761406afe6.png&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660103116&t=8dd0c641e1e1890fa65ee80dfa428d34";
        // img.onload = function () {
        //   // ctx.drawImage(img, 0, 0);
        //   // 后边两位参数 设置宽高进行缩放
        //   // ctx.drawImage(img, 0, 0, 500, 500);
        //   // 在图片的（100，100）位置，裁剪一个300*300大小的内容，然后缩放到500*500绘制到Canvas中（0, 0）的地方
        //   ctx.drawImage(img, 100, 100, 300, 300, 0, 0, 500, 500);
        // };

        // 13、变形
        // ctx.fillStyle = "blue";
        // ctx.fillRect(10, 10, 300, 100);
        // ctx.save(); // 保存状态

        // ctx.fillStyle = "#ee7034";
        // ctx.fillRect(10, 150, 300, 100);

        // ctx.restore(); // 还原到上次保存的状态
        // ctx.fillRect(10, 300, 300, 100);
        // 当保存一个状态，恢复之后可以继续使用，canvas的状态是存储在栈中的，，每次调用save()方法后，当前的状态都会被推送到栈中保存起来
        // PS：保存和恢复可以多次调用， 需要注意的是每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。

        // 变形的状态有：translate(x, y) ，x 是左右偏移量，y 是上下偏移量。
        // 旋转：rotate(angle)，angle是旋转的角度，它是顺时针旋转，以弧度为单位的值。
        // 缩放：scale(x, y)，x 为水平缩放的值，y 为垂直缩放得值。x和y的值小于1则为缩小，大于1则为放大。默认值为 1。
        // ctx.fillStyle = "#ee7034";
        // 保存了两次状态
        // ctx.save();
        // ctx.save();
        // ctx.translate(100, 100); // x和y轴都移动了100
        // ctx.fillRect(0, 0, 100, 100);
        // // 恢复状态，从栈中取出
        // ctx.restore();
        // // 进行选择
        // ctx.rotate(Math.PI / 4); // 旋转了45度，Math.PI=180度
        // ctx.fillRect(0, 0, 100, 100);
        // // 恢复状态，从栈中取出
        // ctx.restore();
        // // 进行缩放
        // ctx.scale(0.5, 1);
        // ctx.fillRect(100, 300, 100, 100);

        // transform、setTransform、resetTransform

        // 14、合成和裁剪
        // source-over是在原有的画布上绘画
        // source-in 新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的
        // source-out在不与现有画布内容重叠的地方绘制新图形
        // source-atop 新图形只在与现有画布内容重叠的地方绘制
        // destination-over 在现有的画布内容后面绘制新的图形
        // destination-in 现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的。
        // destination-out 现有内容保持在新图形不重叠的地方
        // destination-atop 现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的
        // lighter 两个重叠图形的颜色是通过颜色值相加来确定的
        // copy 只显示新图形
        // xor 图像中，那些重叠和正常绘制之外的其他地方是透明的
        // multiply 将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。
        // screen 像素被倒转，相乘，再倒转，结果是一幅更明亮的图片
        // overlay multiply 和 screen 的结合，原本暗的地方更暗，原本亮的地方更亮

        // 获取绘图上下文
        // ctx.beginPath();
        // ctx.fillStyle = "rgba(255, 0, 0, 1)";
        // ctx.fillRect(50, 100, 300, 150);
        // ctx.globalCompositeOperation = "source-atop";
        // ctx.beginPath();
        // ctx.fillStyle = "rgba(0, 255, 0, 1)";
        // ctx.fillRect(50, 150, 150, 250);
        // ctx.globalCompositeOperation = "source-atop";
        // ctx.beginPath();
        // ctx.fillStyle = "rgba(0, 0, 255, 1)";
        // ctx.fillRect(150, 200, 150, 150);

        // 裁剪的作用是遮罩，用来隐藏不需要的部分，所有在路径以外的部分都不会在 canvas 上绘制出来。
        var img = new Image();
        img.src =
          "https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20191212%2F556cc408058d4c64a46468761406afe6.png&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660103116&t=8dd0c641e1e1890fa65ee80dfa428d34";
        img.onload = function () {
          // 创建圆形裁剪路径
          ctx.arc(250, 250, 200, 0, Math.PI * 2, false);
          ctx.clip();
          // 创建完后绘制
          ctx.drawImage(img, 0, 0, 500, 500);
        };
      }
    </script>
  </body>
</html>
