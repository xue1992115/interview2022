<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 
        1、事件冒泡
          * 指的就是事件的传导，就是后代标签上的事件触发的时候，祖先标签上的事件也会触发
          * 事件传播顺序是向上传播，并且是相同的⌚️
          * 优点：
            * 减少事件的绑定
          * 缺点：
            * 触发不必要的函数
            * 解决方法： (event || window.event).cancelBubble = true 取消冒泡
        
        2、事件委派
          * 应用场景：给子元素添加绑定事件，但是对于后添加的元素，可能绑定不上事件；因此可以使用事件委托；将事件绑定在祖先元素上
            * 从而通过祖先元素来处理事件
          * 事件委派就是利用冒泡的方式，可以减少绑定事件的次数，提高代码性能
        3、event.target和event.currentTarget的区别
          * event.target返回触发事件的目标元素（点谁就是谁）
          * event.currentTarget返回绑定事件监听的元素
        4、事件绑定
          * 使用 对象.监听事件 =  函数
          btn.onclick = function() {
            alert('jdjdj')
          }
          这种形式的，只能为元素绑定一次；如果绑定多次相同的事件，则后边的覆盖前面的
          * 如果想要绑定多个事件，可以通过addEventListener()方法
          三个参数： 监听事件 回调函数 是否在捕获阶段触发事件
          btn01.addEventListener('click', function() {}, false)
          * 可以为同一个元素绑定多个相同的事件

        3、事件模型
          * 先说说事件捕获
            * 事件捕获阶段是事件是由外向内进行传播的
            * 事件冒泡阶段是事件是由内向外进行传播的
            * w3c综合上边两种方式
              * 捕获阶段：从最外层的父级元素向内传播
              * 目标阶段：事件捕获到目标元素，捕获结束在目标元素上执行事件
              * 冒泡阶段：从内层的元素向外传播，依次触发父级元素上的事件
              * 如果希望在捕获阶段就执行，addEventListener第三个参数设置为true；但是一般不希望这么做
              * 阻止冒泡：w3c中，使用event.stopPropagation()的方法,IE中event.cancelBubble = true
              * 阻止捕获：阻止事件的默认行为；w3c中，使用event.preventDefault()的方法，在IE下设置window.event.returnValue = false
     -->
    <script></script>
  </body>
</html>
