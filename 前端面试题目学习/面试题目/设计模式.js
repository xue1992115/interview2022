//  共计有23种设计模式，这里学习一些常见的14种的设计模式
// 1、单例设计设计模式
// 单例模式：保证一个类仅有一个实例，并且提供一个访问它的全局访问点
// 经典的案例
// 线程池
// 全局缓存
// 浏览器中的window对象
// 网页登陆浮窗等等
// 2、策略模式
// 定义一系列算法，把他们一个一个封装起来，并且使他们可以相互替换。
// 策略模式利用组合、委托和多态等技术的思想，可以有效的避免多重条件分支语句
// 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的策略类中，使它们易于切换、易于理解、易于扩展。
// 策略模式中的算法也可以复用在系统的其他地方
// 策略模式利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案。
// 应用场景：
// 计算奖金
// 表单的各个元素的验证
// 3、代理模式
// 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。
// 代理模式的关键所在就是：当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象，替身对象作出一些请求后再把请求转接给本体对象
// 4、迭代器模式
// 迭代器模式是指提供一种顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器分为两种，一种是内部迭代器，另外一种是外部迭代器
// 应用场景： 数组中的遍历之类的
// 5、发布订阅模式
// 发布-订阅模式又叫观察者模式，他定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
// 优点： 发布-订阅模式一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更加松耦合的代码编写。发布-订阅模式还可以用来帮助实现一些其他的设计模式，例如中介者模式。
// 缺点：创建订阅者本身要消耗一定的时间和内存，而当你订阅一个消息后，也许此消息最后都没有发生，但订阅者依然存在于内存中，造成了一种浪费。发布-订阅模式虽然弱化了对象之间的联系，但过度使用的话，对象和对象之间的必要联系也将深埋在背后，会导致程序难以追踪维护和理解。
// 应用场景：节点上绑定点击事件就是发布订阅模式
// 常考的就是 手写一个发布订阅模式
// 6、命令模式
// 一个执行某些特定事件的指令。
// 7、组合模式
// 组合模式将对象组合成树形结构，以表示"部分-整体"的层次结构。
// 8、模板方法模式
// 模板方法是一种只需使用继承就可以实现的非常简单的模式。模板方法由两部分组成，一部分是抽象的父类，另一部分是具体的子类。
// 9、职责链模式
// 职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链传递该请求，直到有一个对象处理它为止。
// 10、中介者模式
// 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者即可
// 11、装饰者模式
// 装饰者模式可以动态的给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。
// 12、状态模式
// 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。
// 13、适配器模式
// 适配器模式的作用是解决两个软件实体间的接口不兼容的问题，使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。
